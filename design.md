## Current Architecture
![KeyArt](https://user-images.githubusercontent.com/77936719/115084871-b443fd80-9ec6-11eb-9258-78d533ed6c22.JPG)
![ArchitectureDiagram](https://user-images.githubusercontent.com/77936719/115084813-a2625a80-9ec6-11eb-880e-89e041c014f1.JPG)

Our current architecture is a combination of Client-Server and Publish-Subscribe architectures. In regards to the Client-Server side of our architecture our same itself will be on the server side and will be downloaded and run on the clients side. This is the only interactioon between the client and our server since our game is not online. In a Publish-Subscribe architecture components of the project will react to events as they occur. In the case of our project our components will be the player and the game world, while events will be reactions such as combat and completing tasks that the player and the game world will react to. An example of this is the player will react to enemies attacking them by loosing health and vice versa. Another example is how the level will react by opening up more when certain tasks are completed on each floor.

## Class Description

Our project contains quite a several classes however the most critical ones are our AbilitySystem, AI, and Level classes. The Ability Systems class controls all of the assets that make up the ability system including the icons, logic, UI and ability animations for the ability system are built and stored here. Ability System has contains several child classes; Ability_Projectile, Ability_AoE, Ability_Buff, and Ability_Debuff. Each one of these child classes inherits important characteristics that our main Ability class has. This includes functions such as BeginCasting, CastAbility, InterruptCast, and ActivateEffect. These functions are imperative for casting certain powers during the game or checking the current state of abilities. These also directly connects to our UI in the center middle part of our HUD. The ability system communicates with the Main HUD to check if enough power is availbe to cast an ability or checking whether a cooldown is finished. These charactertics and boundaries allow for a more unique and fluid experience. As the HUD conststantly updates its current state it then connects to the direct gameplay of the player. As the player inputs constatnt commands the gamestate and HUD must iterate to keep up with the proper state. 
The second major part of our classes consist of the Enemy AI behavior tree. This is a specific blackboard that is a event dispatcher and gives commands on how the AI should react on certain scenarios. This is a local repository that communicates back and forth between the AI Controllers and the enviroment around the player. This allows for unique and more interactive AI that can determine where the player is located and when to attack. This AI utilizes a combat director to determine the exact turn for which enemy is allowed to attack. This creates a more gamelike sense where the player is given proper time to come up with a strategy or retreat. 
